<html>

<head>
    <meta charset="utf-8">
    <title>中国地图</title>
    <script src='lib/FileSaver.min.js'></script>
</head>
<style>

</style>

<body>
    <button onclick="load('九段线.json')">九段线</button>
    <button onclick="load('全球行政区划.json')">全球行政区划</button>
    <button onclick="load('中国地图_带九段线_钓鱼岛_三沙各群岛.json')">中国轮廓</button>
    <button onclick="load('中国地图_各省市区_带九段线_钓鱼岛_三沙各群岛.json')">带省轮廓</button>
    <button onclick="load('中国地图_各省地市_带九段线_钓鱼岛_三沙各群岛.json')">带省地市</button>
    <script src="http://d3js.org/d3.v3.min.js"></script>
    <script>


        var width = 600;
        var height = 600;

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(0,0)");

        var projection = d3.geo.mercator()
            .center([107, 31])
            .scale(450)
            .translate([width / 2, height / 2]);

        var path = d3.geo.path()
            .projection(projection);


        var color = d3.scale.category20();

        function downloadGeoJson(fileStr, geojson) {
            var str = JSON.stringify(geojson);
            var blob = new Blob([str], {
                type: 'text/plain;charset=utf8'
            });
            var fileName = [];
            fileName.push(fileStr);
            fileName.push('json');
            saveAs(blob, fileName.join('.'));

        }

        function load(url) {

            d3.json("tmpjson/" + url, function (error, root) {
                if (error) {
                    return console.error(error);
                }
                if (url.indexOf("行政") > 0) {
                    projection = d3.geo.mercator()
                        .center([107, 31])
                        .scale(100)
                        .translate([width / 2, height / 2]);
                } else {
                    projection = d3.geo.mercator()
                        .center([107, 31])
                        .scale(450)
                        .translate([width / 2, height / 2]);
                }
                path = d3.geo.path().projection(projection);

                const newObj = JSON.parse(JSON.stringify(root));
                let tmp = compress(newObj);
               // downloadGeoJson(url, tmp);
                console.log(tmp);
                root = decode(tmp);
                svg.html("");
                svg.selectAll("path")
                    .data(root.features)
                    .enter()
                    .append("path")
                    .attr("stroke", "#000")
                    .attr("stroke-width", 1)
                    .attr("fill", function (d, i) {
                        return color(i);
                    })
                    .attr("d", path)
                    .on("mouseover", function (d, i) {
                        d3.select(this)
                            .attr("fill", "yellow");
                    })
                    .on("mouseout", function (d, i) {
                        d3.select(this)
                            .attr("fill", color(i));
                    });

            });
        }





        function compress(json) {

            json.UTF8Encoding = true;

            var features = json.features;
            if (!features) {
                return;
            }
            features.forEach(function (feature) {
                var encodeOffsets = feature.geometry.encodeOffsets = [];
                var coordinates = feature.geometry.coordinates;
                if (feature.geometry.type === 'Polygon') {
                    coordinates.forEach(function (coordinate, idx) {
                        coordinates[idx] = encodePolygon(
                            coordinate, encodeOffsets[idx] = []
                        );
                    });
                } else if (feature.geometry.type === 'MultiPolygon') {
                    coordinates.forEach(function (polygon, idx1) {
                        encodeOffsets[idx1] = [];
                        polygon.forEach(function (coordinate, idx2) {
                            coordinates[idx1][idx2] = encodePolygon(
                                coordinate, encodeOffsets[idx1][idx2] = []
                            );
                        });
                    });
                }
            });

            return json;
        }

        function encodePolygon(coordinate, encodeOffsets) {

            var result = '';

            var prevX = quantize(coordinate[0][0]);
            var prevY = quantize(coordinate[0][1]);
            // Store the origin offset
            encodeOffsets[0] = prevX;
            encodeOffsets[1] = prevY;

            for (var i = 0; i < coordinate.length; i++) {
                var point = coordinate[i];
                result += encode(point[0], prevX);
                result += encode(point[1], prevY);

                prevX = quantize(point[0]);
                prevY = quantize(point[1]);
            }
            return result;
        }

        function quantize(val) {
            return Math.ceil(val * 1024);
        }

        function encode(val, prev) {
            // Quantization
            val = quantize(val);
            // var tmp = val;
            // Delta
            val = val - prev;

            if (((val << 1) ^ (val >> 15)) + 64 === 8232) {
                //WTF, 8232 will get syntax error in js code
                val--;
            }
            // ZigZag
            val = (val << 1) ^ (val >> 15);
            // add offset and get unicode
            return String.fromCharCode(val + 64);
            // var tmp = {'tmp' : str};
            // try{
            //     eval("(" + JSON.stringify(tmp) + ")");
            // }catch(e) {
            //     console.log(val + 64);
            // }
        }



        function decode(json) {
            if (!json.UTF8Encoding) {
                return json;
            }
            var encodeScale = json.UTF8Scale;
            if (encodeScale == null) {
                encodeScale = 1024;
            }

            var features = json.features;

            for (var f = 0; f < features.length; f++) {
                var feature = features[f];
                var geometry = feature.geometry;
                var coordinates = geometry.coordinates;
                var encodeOffsets = geometry.encodeOffsets;

                for (var c = 0; c < coordinates.length; c++) {
                    var coordinate = coordinates[c];

                    if (geometry.type === 'Polygon') {
                        coordinates[c] = this.decodePolygon(
                            coordinate,
                            encodeOffsets[c],
                            encodeScale
                        );
                    } else if (geometry.type === 'MultiPolygon') {
                        for (var c2 = 0; c2 < coordinate.length; c2++) {
                            var polygon = coordinate[c2];
                            coordinate[c2] = decodePolygon(
                                polygon,
                                encodeOffsets[c][c2],
                                encodeScale
                            );
                        }
                    }
                }
            }
            // Has been decoded
            json.UTF8Encoding = false;
            return json;
        }

        function decodePolygon(coordinate, encodeOffsets, encodeScale) {
            var result = [];
            var prevX = encodeOffsets[0];
            var prevY = encodeOffsets[1];

            for (var i = 0; i < coordinate.length; i += 2) {
                var x = coordinate.charCodeAt(i) - 64;
                var y = coordinate.charCodeAt(i + 1) - 64;
                // ZigZag decoding
                x = (x >> 1) ^ (-(x & 1));
                y = (y >> 1) ^ (-(y & 1));
                // Delta deocding
                x += prevX;
                y += prevY;

                prevX = x;
                prevY = y;
                result.push([x / encodeScale, y / encodeScale]);
            }
            return result;
        }
    </script>
</body>

</html>